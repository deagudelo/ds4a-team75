sm2
###reviewing for need of overdispersion parameter
(dLL<- 2*(logLik(m1)-logLik(m2)))
#comparing models to determine the need of overdispersion parameter
pchisq(dLL,df=1, lower.tail=FALSE)
datosb$NumberOT
mean(datosb$NumberOT)
var(datosb$NumberOT)
plot(m1)
#fitting the positive negative binomial regression
m1<-vglm(NumberOT ~ C(ServiceType) + C(District) + C(as.factor(Month)), family=posnegbinomial(), data=datosb)
plot(m1)
plot(m1, se = TRUE, which.cf = 1:2, lcol = "blue", scol = "orange",
ylim = c(-3, 2))
plot(m1, se = TRUE, which.cf = 1:2, las = 1 ,lcol = "blue", scol = "orange",
ylim = c(-3, 2))
#fitting the positive negative binomial regression
m1<-vglm(NumberOT ~ s(ServiceType) + s(District) + s(as.factor(Month)), family=posnegbinomial(), data=datosb)
plot(m1)
#input data for plots
output<-data.frame(resid=resid(m1)[,1], fitted=fitted(m1))
#plot fitted vs resid
ggplot(output, aes(fitted,resid))+geom_jitter(position=position_jitter(width=0.25),
alpha=0.5) + stat_smooth(method="loess")
#plot of fited vs resid with quantiles
ggplot(output, aes(fitted,resid))+geom_jitter(position=position_jitter(width=0.25),
alpha=0.5) + stat_quantile(method="rq")
#Data for fitted vs resid, suign bins of fitted
output <- within(output, {
broken <- cut(fitted, hist(fitted, plot=FALSE)$breaks)
})
ggplot(output, aes(broken, resid))+
geom_boxplot()+
geom_jitter(alpha=0.25)
datosb$predict_round<- round(datosb$predicted,0)
View(datosb)
#adding probablities to data
datosb$prob1<-dposnegbin(1, munb = datosb$predicted, size = size)
datosb$prob2<-dposnegbin(2, munb = datosb$predicted, size = size)
datosb$prob3<-dposnegbin(3, munb = datosb$predicted, size = size)
datosb$prob4<-dposnegbin(4, munb = datosb$predicted, size = size)
datosb$dif_pred=datosb$NumberOT - datosb$predict_round
summary(datosb$dif_pred)
ggplot(datosb, aes(prob1, fill=District:ServiceType))+
geom_boxplot()
ggplot(datosb, aes(datosb$prob1, fill=District:ServiceType))+
geom_boxplot()
ggplot(datosb, aes(Month, prob1, fill=District:ServiceType))+
geom_boxplot()
ggplot(datosb, aes(as.factor(Month), prob1, fill=District:ServiceType))+
geom_boxplot()
ggplot(datosb, aes(as.factor(Month), prob1))+
geom_boxplot()
###Imagenes para hacer en python
ggplot(datosb, aes(as.factor(Month), prob1, fill=District))+
geom_boxplot()
###Imagenes para hacer en python
ggplot(datosb, aes(as.factor(Month), prob1, fill=District*ServiceType))+
geom_boxplot()
###Imagenes para hacer en python
ggplot(datosb, aes(as.factor(Month), prob1, fill=District:ServiceType))+
geom_boxplot()
###Imagenes para hacer en python
ggplot(datosb, aes(as.factor(Month), prob1, fill=District))+
geom_boxplot()+
xlab("Mes del año")+
ylab("Probabilidad de una falla")
ggplot(datosb, aes(as.factor(Month), prob1, fill=ServiceType))+
geom_boxplot()+
xlab("Mes del año")+
ylab("Probabilidad de una falla")
ggplot(datosb, aes(as.factor(Month), prob1, fill=ServiceType))+
geom_boxplot()+
xlab("Month")+
ylab("Probabity of one failure")+
scale_fill_discrete(name = "Service type", labels = c("Energy dammages", "Energy maintenance"))
ggplot(datosb, aes(as.factor(Month), prob1, fill=ServiceType))+
geom_boxplot()+
xlab("Month")+
ylab("Probabity of one failure")+
scale_fill_discrete(name = "Service type", labels = c("Energy damages", "Energy maintenance"))
###Imagenes para hacer en python
ggplot(datosb, aes(as.factor(Month), prob1, fill=District))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of one failure")+
scale_fill_discrete(name = "District", labels = c("Apartadó TyD", "Turbo TyD"))
ggplot(datosb, aes(as.factor(Month), prob1, fill=ServiceType))+
geom_boxplot()+
xlab("Month")+
ylab("Probabity of one failure")+
scale_fill_discrete(name = "Service type", labels = c("Energy damages", "Energy maintenance"))
###Imagenes para hacer en python
ggplot(datosb, aes(as.factor(Month), prob1, fill=District))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of one failure")+
scale_fill_discrete(name = "District", labels = c("Apartadó TyD", "Turbo TyD"))
View(datosb)
###plots of resulting probabilities of more than 3 failures by covariates
ggplot(datosb, aes(as.factor(Month), prob_may_3, fill=District))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of three failures")+
scale_fill_discrete(name = "District", labels = c("Apartadó TyD", "Turbo TyD"))
ggplot(datosb, aes(as.factor(Month), prob_may_3, fill=ServiceType))+
geom_boxplot()+
xlab("Month")+
ylab("Probabity of three failures")+
scale_fill_discrete(name = "Service type", labels = c("Energy damages", "Energy maintenance"))
datosb$prob_may_3<-1-(datosb$prob1+datosb$prob2+datosb$prob3)
#adding probablities to data
datosb$prob1<-dposnegbin(1, munb = datosb$predicted, size = size)
datosb$prob2<-dposnegbin(2, munb = datosb$predicted, size = size)
datosb$prob3<-dposnegbin(3, munb = datosb$predicted, size = size)
datosb$prob4<-dposnegbin(4, munb = datosb$predicted, size = size)
datosb$prob_may_3<-1-(datosb$prob1+datosb$prob2+datosb$prob3)
datosb$predict_round<- round(datosb$predicted,0)
###plots of resulting probabilities of one failure by covariates
ggplot(datosb, aes(as.factor(Month), prob1, fill=District))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of one failure")+
scale_fill_discrete(name = "District", labels = c("Apartadó TyD", "Turbo TyD"))
ggplot(datosb, aes(as.factor(Month), prob1, fill=ServiceType))+
geom_boxplot()+
xlab("Month")+
ylab("Probabity of one failure")+
scale_fill_discrete(name = "Service type", labels = c("Energy damages", "Energy maintenance"))
ggplot(datosb, aes(as.factor(Month), prob2, fill=ServiceType))+
geom_boxplot()+
xlab("Month")+
ylab("Probabity of two failures")+
scale_fill_discrete(name = "Service type", labels = c("Energy damages", "Energy maintenance"))
ggplot(datosb, aes(as.factor(Month), prob1, fill=ServiceType))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of one failure")+
scale_fill_discrete(name = "Service type", labels = c("Energy damages", "Energy maintenance"))
ggplot(datosb, aes(as.factor(Month), prob2, fill=ServiceType))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of two failures")+
scale_fill_discrete(name = "Service type", labels = c("Energy damages", "Energy maintenance"))
ggplot(datosb, aes(as.factor(Month), prob2, fill=District))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of two failures")+
scale_fill_discrete(name = "District", labels = c("Apartadó TyD", "Turbo TyD"))
###plots of resulting probabilities of 3 failures by covariates
ggplot(datosb, aes(as.factor(Month), prob3, fill=District))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of three failures")+
scale_fill_discrete(name = "District", labels = c("Apartadó TyD", "Turbo TyD"))
###plots of resulting probabilities of 3 failures by covariates
ggplot(datosb, aes(as.factor(Month), prob3, fill=District))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of three failures")+
scale_fill_discrete(name = "District", labels = c("Apartadó TyD", "Turbo TyD"))
ggplot(datosb, aes(as.factor(Month), prob_may_3, fill=ServiceType))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of three failures")+
scale_fill_discrete(name = "Service type", labels = c("Energy damages", "Energy maintenance"))
###plots of resulting probabilities of more than 3 failures by covariates
ggplot(datosb, aes(as.factor(Month), prob_may_3, fill=District))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of three failures")+
scale_fill_discrete(name = "District", labels = c("Apartadó TyD", "Turbo TyD"))
###plots of resulting probabilities of more than 3 failures by covariates
ggplot(datosb, aes(as.factor(Month), prob_may_3, fill=District))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of three failures")+
scale_fill_discrete(name = "District", labels = c("Apartadó TyD", "Turbo TyD"))
ggplot(datosb, aes(as.factor(Month), prob_may_3, fill=ServiceType))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of more than three failures")+
scale_fill_discrete(name = "Service type", labels = c("Energy damages", "Energy maintenance"))
###plots of resulting probabilities of more than 3 failures by covariates
ggplot(datosb, aes(as.factor(Month), prob_may_3, fill=District))+
geom_boxplot()+
xlab("Month")+
ylab("Probability of more than three failures")+
scale_fill_discrete(name = "District", labels = c("Apartadó TyD", "Turbo TyD"))
#making histograms of response variables and predicted values
ggplot(datosb, aes(NumberOT))+
geom_histogram()
ggplot(datosb, aes(predict_round))+
geom_histogram()
ggplot(datosb, aes(predicted))+
geom_histogram()
mean(datosb$NumberOT)
var(datosb$NumberOT)
mean(datosb$predict_round)
var(datosb$predict_round)
var(datosb$predict_round) + size
var(datosb$predict_round) + size
varfit=var(datosb$predict_round) + size
varfit
var(datosb$predict_round)
#setting working directory
setwd("~/Repo/ds4a-team75")
#importing libraries
library("VGAM")
library("data.table")
library("ggplot2")
library("readxl")
library("xtable")
library( broom )
library(EnvStats)
#loading data
datos <- read.csv("~/Repo/ds4a-team75/datos.csv")
#converting data into data table
datos<-as.data.table(datos)
#identifying optimal transformation to data to identify outliers
a=boxcox(as.numeric(datos[["NumberOT"]]), optimize=TRUE)
l=a$lambda
#saving trasnformed data
datos[,"BC_NumberOT"] = (datos[,"NumberOT"]^(l) -1)/l
#using a boxplot to idenify outliers
b=boxplot(datos[,"BC_NumberOT"])
#filtering outliers
datosb<-datos[BC_NumberOT< b$stats[5],]
#fitting the positive negative binomial regression
m1<-vglm(NumberOT ~ c(ServiceType) + c(District) + c(as.factor(Month)), family=posnegbinomial(), data=datosb)
#making plots of residuals vs fitted values an linear predictors mu, size
plot(m1)
setwd("~/Repo/ds4a-team75")
#importing libraries
library("VGAM")
library("data.table")
library("ggplot2")
library("readxl")
library("xtable")
library( broom )
library(EnvStats)
datos <- read.csv("~/Repo/ds4a-team75/datos.csv")
#converting data into data table
datos<-as.data.table(datos)
#identifying optimal transformation to data to identify outliers
a=boxcox(as.numeric(datos[["NumberOT"]]), optimize=TRUE)
l=a$lambda
#saving trasnformed data
datos[,"BC_NumberOT"] = (datos[,"NumberOT"]^(l) -1)/l
#using a boxplot to idenify outliers
b=boxplot(datos[,"BC_NumberOT"])
#filtering outliers
datosb<-datos[BC_NumberOT< b$stats[5],]
m1<-vglm(NumberOT ~ c(ServiceType) + c(District) + c(as.factor(Month)), family=posnegbinomial(), data=datosb)
#making plots of residuals vs fitted values an linear predictors mu, size
plot(m1)
#saving the main outputs related with the model
sm1=summary(m1)
sink("lm.png")
print(summary(m1))
sink()
m2 <- vglm(NumberOT ~ ServiceType + District + as.factor(Month), family = pospoisson(), data = datosb)
#saving the main outputs related with the model
sm2=summary(m2)
datosb$prob1<-dposnegbin(1, munb = datosb$predicted, size = size)
datosb$prob2<-dposnegbin(2, munb = datosb$predicted, size = size)
datosb$prob3<-dposnegbin(3, munb = datosb$predicted, size = size)
datosb$prob4<-dposnegbin(4, munb = datosb$predicted, size = size)
datosb$prob_may_3<-1-(datosb$prob1+datosb$prob2+datosb$prob3)
logmunb<-sm1@coefficients[1]
logsize<-sm1@coefficients[2]
munb<-exp(logmunb)
size<-exp(logsize)
datosb$prob1<-dposnegbin(1, munb = datosb$predicted, size = size)
datosb$prob2<-dposnegbin(2, munb = datosb$predicted, size = size)
datosb$prob3<-dposnegbin(3, munb = datosb$predicted, size = size)
datosb$prob4<-dposnegbin(4, munb = datosb$predicted, size = size)
datosb$prob_may_3<-1-(datosb$prob1+datosb$prob2+datosb$prob3)
logmunb
logsize
munb
size
#adding probablities of 1, 2, 3 or more than three failures
datosb$prob1<-dposnegbin(1, munb = datosb$predicted, size = size)
datosb$predicted<-data.frame(fitted(m1))
datosb$predict_round<- round(datosb$predicted,0)
#adding probablities of 1, 2, 3 or more than three failures
datosb$prob1<-dposnegbin(1, munb = datosb$predicted, size = size)
datosb$prob2<-dposnegbin(2, munb = datosb$predicted, size = size)
datosb$prob3<-dposnegbin(3, munb = datosb$predicted, size = size)
datosb$prob4<-dposnegbin(4, munb = datosb$predicted, size = size)
datosb$prob_may_3<-1-(datosb$prob1+datosb$prob2+datosb$prob3)
#adding a the difference between predicted round counts and original counts
datosb$dif_pred=datosb$NumberOT - datosb$predict_round
#making histograms of response variables and predicted values
ggplot(datosb, aes(NumberOT))+
geom_histogram()
ggplot(datosb, aes(predict_round))+
geom_histogram()
ggplot(datosb, aes(predicted))+
geom_histogram()
fitted(m1)
#input data for plots
output<-data.frame(resid=resid(m1)[,1], fitted=fitted(m1))
#plot fitted vs resid
ggplot(output, aes(fitted,resid))+geom_jitter(position=position_jitter(width=0.25),
alpha=0.5) + stat_smooth(method="loess")
#adding a the difference between predicted round counts and original counts
datosb$dif_pred=datosb$NumberOT - datosb$predict_round
#making histograms of response variables and predicted values
ggplot(datosb, aes(NumberOT))+
geom_histogram()
ggplot(datosb, aes(predict_round))+
geom_histogram()
ggplot(datosb, aes(predicted))+
geom_histogram()
#input data for plots
output<-data.frame(resid=resid(m1)[,1], fitted=fitted(m1))
#plot fitted vs resid
ggplot(output, aes(fitted,resid))+geom_jitter(position=position_jitter(width=0.25),
alpha=0.5) + stat_smooth(method="loess")
#plot of fited vs resid with quantiles
ggplot(output, aes(fitted,resid))+geom_jitter(position=position_jitter(width=0.25),
alpha=0.5) + stat_quantile(method="rq")
#Data for fitted vs resid, sign bins of fitted
output <- within(output, {
broken <- cut(fitted, hist(fitted, plot=FALSE)$breaks)
})
ggplot(output, aes(broken, resid))+
geom_boxplot()+
geom_jitter(alpha=0.25)
###reviewing for need of overdispersion parameter
(dLL<- 2*(logLik(m1)-logLik(m2)))
#comparing models to determine the need of overdispersion parameter
pchisq(dLL,df=1, lower.tail=FALSE)
#getting the mean and variance
mean(datosb$NumberOT)
var(datosb$NumberOT)
mean(datosb$predict_round)
varfit=var(datosb$predict_round) + size
varfit
###printig data to plot in maps
write.csv(datosb,"map_data.csv")
#fitting the positive negative binomial regression
m1<-vglm(NumberOT ~ c(ServiceType) + c(District) + c(as.factor(Month)) +c(day), family=posnegbinomial(), data=datosb)
#saving the main outputs related with the model
sm1=summary(m1)
sm1
View(datosb)
#fitting the positive negative binomial regression
m1<-vglm(NumberOT ~ c(ServiceType) + c(District) + as.factor(Month) +as.factor(day), family=posnegbinomial(), data=datosb)
#saving the main outputs related with the model
sm1=summary(m1)
sm1
#loading data
datos <- read.csv("~/Repo/ds4a-team75/datos.csv")
#converting data into data table
datos<-as.data.table(datos)
#identifying optimal transformation to data to identify outliers
a=boxcox(as.numeric(datos[["NumberOT"]]), optimize=TRUE)
l=a$lambda
#saving trasnformed data
datos[,"BC_NumberOT"] = (datos[,"NumberOT"]^(l) -1)/l
#using a boxplot to idenify outliers
b=boxplot(datos[,"BC_NumberOT"])
#filtering outliers
datosb<-datos[BC_NumberOT< b$stats[5],]
#fitting the positive negative binomial regression
m1<-vglm(NumberOT ~ c(ServiceType) + c(District) + as.factor(Month) +as.factor(weekday), family=posnegbinomial(), data=datosb)
#saving the main outputs related with the model
sm1=summary(m1)
sm1
#making plots of residuals vs fitted values an linear predictors mu, size
plot(m1)
#fitting the positive poisson regression
m2 <- vglm(NumberOT ~ ServiceType + District + as.factor(Month) +as.factor(weekday), family = pospoisson(), data = datosb)
#saving the main outputs related with the model
sm2=summary(m2)
#extracting log a not log mean and size
logmunb<-sm1@coefficients[1]
logsize<-sm1@coefficients[2]
munb<-exp(logmunb)
size<-exp(logsize)
#adding a the predicted round counts
datosb$predicted<-data.frame(fitted(m1))
datosb$predict_round<- round(datosb$predicted,0)
#adding probablities of 1, 2, 3 or more than three failures
datosb$prob1<-dposnegbin(1, munb = datosb$predicted, size = size)
datosb$prob2<-dposnegbin(2, munb = datosb$predicted, size = size)
datosb$prob3<-dposnegbin(3, munb = datosb$predicted, size = size)
datosb$prob4<-dposnegbin(4, munb = datosb$predicted, size = size)
datosb$prob_may_3<-1-(datosb$prob1+datosb$prob2+datosb$prob3)
#adding a the difference between predicted round counts and original counts
datosb$dif_pred=datosb$NumberOT - datosb$predict_round
#making histograms of response variables and predicted values
ggplot(datosb, aes(NumberOT))+
geom_histogram()
ggplot(datosb, aes(predict_round))+
geom_histogram()
ggplot(datosb, aes(predicted))+
geom_histogram()
#making histograms of response variables and predicted values
ggplot(datosb, aes(NumberOT))+
geom_histogram()
#input data for plots
output<-data.frame(resid=resid(m1)[,1], fitted=fitted(m1))
#plot fitted vs resid
ggplot(output, aes(fitted,resid))+geom_jitter(position=position_jitter(width=0.25),
alpha=0.5) + stat_smooth(method="loess")
datosb$residuals<-data.frame(resid=resid(m1)[,1])
View(datosb)
###filtering strange data
datosb1<-datosb[abs(residuals)<20,]
a=datosb[abs(residuals)>6,]
###filtering strange data
datosb1<-datosb[abs(residuals)<6,]
####fitting the model without strange data
m1b<-vglm(NumberOT ~ c(ServiceType) + c(District) + as.factor(Month) +as.factor(weekday), family=posnegbinomial(), data=datosb1)
#input data for plots
output<-data.frame(resid=resid(m1b)[,1], fitted=fitted(m1b))
#plot fitted vs resid
ggplot(output, aes(fitted,resid))+geom_jitter(position=position_jitter(width=0.25),
alpha=0.5) + stat_smooth(method="loess")
plot(m1b)
###printig data to plot in maps
write.csv(datosb1,"map_data.csv")
View(datosb1)
a=length(datosb1[predict_round==NumberOT])
a
a=length(datosb1[predict_round==NumberOT+1])
a
a=length(datosb1[predict_round==NumberOT,])
a=nrow(datosb1[predict_round==NumberOT,])
a=nrow(datosb1[abs(dif_pred)<2,])
a=nrow(datosb1[abs(dif_pred)<3,])
a=nrow(datosb1[abs(dif_pred)<5,])
#loading data
datos <- read.csv("~/Repo/ds4a-team75/datos.csv")
#converting data into data table
datos<-as.data.table(datos)
#identifying optimal transformation to data to identify outliers
a=boxcox(as.numeric(datos[["NumberOT"]]), optimize=TRUE)
l=a$lambda
#saving trasnformed data
datos[,"BC_NumberOT"] = (datos[,"NumberOT"]^(l) -1)/l
#using a boxplot to idenify outliers
b=boxplot(datos[,"BC_NumberOT"])
#filtering outliers
datosb<-datos[BC_NumberOT< b$stats[5],]
#fitting the positive negative binomial regression
m1<-vglm(NumberOT ~ c(ServiceType) + c(District) + as.factor(Month) +as.factor(weekday), family=posnegbinomial(), data=datosb)
#making plots of residuals vs fitted values an linear predictors mu, size
plot(m1)
#saving the main outputs related with the model
sm1=summary(m1)
#input data for plots
output<-data.frame(resid=resid(m1)[,1], fitted=fitted(m1))
#plot fitted vs resid
ggplot(output, aes(fitted,resid))+geom_jitter(position=position_jitter(width=0.25),
alpha=0.5) + stat_smooth(method="loess")
#making histograms of response variables and predicted values
ggplot(datosb, aes(NumberOT))+
geom_histogram()
ggplot(datosb, aes(predict_round))+
geom_histogram()
#extracting log a not log mean and size
logmunb<-sm1@coefficients[1]
logsize<-sm1@coefficients[2]
munb<-exp(logmunb)
size<-exp(logsize)
#adding a the predicted round counts
datosb$predicted<-data.frame(fitted(m1))
datosb$predict_round<- round(datosb$predicted,0)
#adding probablities of 1, 2, 3 or more than three failures
datosb$prob1<-dposnegbin(1, munb = datosb$predicted, size = size)
datosb$prob2<-dposnegbin(2, munb = datosb$predicted, size = size)
datosb$prob3<-dposnegbin(3, munb = datosb$predicted, size = size)
datosb$prob4<-dposnegbin(4, munb = datosb$predicted, size = size)
datosb$prob_may_3<-1-(datosb$prob1+datosb$prob2+datosb$prob3)
##I have doubts about the size...
datosb$resid<-data.frame(fitted(m1))
#adding a the difference between predicted round counts and original counts
datosb$dif_pred<-datosb$NumberOT - datosb$predict_round
datosb$residuals<-data.frame(resid=resid(m1)[,1])
#making histograms of response variables and predicted values
ggplot(datosb, aes(NumberOT))+
geom_histogram()
ggplot(datosb, aes(predict_round))+
geom_histogram()
#input data for plots
output<-data.frame(resid=resid(m1)[,1], fitted=fitted(m1))
#plot fitted vs resid
ggplot(output, aes(fitted,resid))+geom_jitter(position=position_jitter(width=0.25),
alpha=0.5) + stat_smooth(method="loess")
####fitting the model without strange data
m1b<-vglm(NumberOT ~ c(ServiceType) + c(District) + as.factor(Month) +as.factor(weekday), family=posnegbinomial(), data=datosb1)
###filtering strange data
datosb1<-datosb[abs(residuals)<6,]
####fitting the model without strange data
m1b<-vglm(NumberOT ~ c(ServiceType) + c(District) + as.factor(Month) +as.factor(weekday), family=posnegbinomial(), data=datosb1)
plot(m1b)
#input data for plots
output<-data.frame(resid=resid(m1b)[,1], fitted=fitted(m1b))
#plot fitted vs resid
ggplot(output, aes(fitted,resid))+geom_jitter(position=position_jitter(width=0.25),
alpha=0.5) + stat_smooth(method="loess")
###printig data to plot in maps
write.csv(datosb1,"map_data.csv")
###printig data to plot in maps
write.csv(datosb1,"map_data.csv")
###printig data to plot in maps
write.csv(datosb1,"map_data.csv")
